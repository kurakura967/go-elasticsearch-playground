# GoによるElasticsearchへの並行バルクインサート性能比較

このディレクトリには、Go言語を使用してElasticsearchにデータをバルクインサートする際の、複数の並行処理実装パターンとそのパフォーマンスを比較・検証するためのコードが含まれています。

## 目的

`go-elasticsearch`ライブラリの`esutil.BulkIndexer`を利用して、大量のドキュメントを効率的にインサートする方法を探求します。特に、自前での並行処理実装と、ライブラリが提供する内部的な並行処理機能の性能を比較し、ベストプラクティスを明らかにすることを目的とします。

## ファイル構成

-   `insert.go`: Elasticsearchへのバルクインサート処理を実装した関数が含まれています。複数の異なるアプローチの関数が定義されています。
-   `insert_test.go`: 各インサート関数の性能を測定するためのベンチマークテストが含まれています。

## 実装された関数

### 1. `BulkInsert`

-   **概要:** 最も基本的なバルクインサート処理。
-   **実装:** `esutil.NewBulkIndexer`を1つ生成し、すべてのドキュメントを逐次的に追加します。性能比較のベースラインとなります。

### 2. `BulkInsertConcurrent` (非効率な例)

-   **概要:** 並行処理のナイーブな実装例。
-   **実装:** ドキュメントをチャンクに分割し、チャンクごとにgoroutineを起動します。**各goroutineの内部で`BulkIndexer`を都度生成**しています。
-   **問題点:** `BulkIndexer`の生成コストは高いため、これを何度も繰り返すことで甚大なオーバーヘッドが発生します。結果として、ドキュメント数が多くなると逐次処理よりも大幅に性能が劣化します。

### 3. `BulkInsertConcurrentV2`

-   **概要:** 改善された並行処理の実装例。
-   **実装:** 最初に単一の`BulkIndexer`を生成します。`Add`メソッドの呼び出し自体を、自前の複数のワーカーgoroutineで並行化しています。

### 4. `BulkInsertConcurrentV3` (推奨される実装)

-   **概要:** 最もシンプルかつ効率的な並行処理の実装例。
-   **実装:** 最初に単一の`BulkIndexer`を生成し、その`NumWorkers`パラメータで並行度を指定します。ドキュメントの追加は単純なforループで行い、**並行処理は`BulkIndexer`の内部機構に完全に任せます。**
-   **利点:** クライアント側の実装が非常にシンプルになり、ライブラリの最適化を最大限に活用できます。

## 実行方法

以下のコマンドを実行することで、各関数のベンチマークを測定できます。

```bash
go test -bench=. -benchmem
```

## ベンチマーク結果 (例)

Apple M3 Pro環境での実行結果です。

| 関数 | 100件 (ns/op) | 1,000件 (ns/op) | 10,000件 (ns/op) |
| :--- | :--- | :--- | :--- |
| `BulkInsert` (通常) | 18,605,576 | 25,608,865 | 73,776,654 |
| `BulkInsertConcurrent` (V1) | 18,324,953 | 40,274,527 | 429,154,572 |
| `BulkInsertConcurrentV2` (V2) | **16,261,372** | **23,182,419** | **73,282,796** |
| `BulkInsertConcurrentV3` (V3) | 16,772,930 | 24,745,583 | 86,478,891 |

※ `ns/op` は1回の操作あたりのナノ秒。数値が小さいほど高速です。

## 結論・考察

-   **並行処理は正しく実装しないと逆効果:** `BulkInsertConcurrent` (V1) の結果が示すように、誤った並行処理は逐次処理よりも大幅に遅くなります。特に、`BulkIndexer`のような高コストなオブジェクトをループ内で都度生成するのは避けるべきです。
-   **ライブラリを信頼するのが最善手:** `BulkInsertConcurrentV2`と`V3`の結果は、`BulkIndexer`を一度だけ生成し、その内部並行処理機能（`NumWorkers`）に任せるアプローチが非常に効果的であることを示しています。
-   **シンプルさが正義:** V2とV3の性能は非常に近いですが、コードのシンプルさ、可読性、メンテナンス性の観点から、**V3の実装がベストプラクティス**と言えます。クライアント側のオーバーヘッドを最小限に抑え、ライブラリの性能を最大限に引き出すことができます。
